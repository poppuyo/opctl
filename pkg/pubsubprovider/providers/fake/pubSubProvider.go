// This file was generated by counterfeiter
package fake

import (
  "sync"

  "github.com/opspec-io/engine/pkg/pubsubprovider"
)

type PubSubProvider struct {
  CreateTopicIfNotExistsStub        func(topicId string) (topic pubsubprovider.Topic, err error)
  createTopicIfNotExistsMutex       sync.RWMutex
  createTopicIfNotExistsArgsForCall []struct {
    topicId string
  }
  createTopicIfNotExistsReturns     struct {
                                      result1 pubsubprovider.Topic
                                      result2 error
                                    }
  DeleteTopicIfExistsStub           func(topicId string) (err error)
  deleteTopicIfExistsMutex          sync.RWMutex
  deleteTopicIfExistsArgsForCall    []struct {
    topicId string
  }
  deleteTopicIfExistsReturns        struct {
                                      result1 error
                                    }
  GetTopicStub                      func(topicId string) (topic pubsubprovider.Topic, err error)
  getTopicMutex                     sync.RWMutex
  getTopicArgsForCall               []struct {
    topicId string
  }
  getTopicReturns                   struct {
                                      result1 pubsubprovider.Topic
                                      result2 error
                                    }
  invocations                       map[string][][]interface{}
  invocationsMutex                  sync.RWMutex
}

func (fake *PubSubProvider) CreateTopicIfNotExists(topicId string) (topic pubsubprovider.Topic, err error) {
  fake.createTopicIfNotExistsMutex.Lock()
  fake.createTopicIfNotExistsArgsForCall = append(fake.createTopicIfNotExistsArgsForCall, struct {
    topicId string
  }{topicId})
  fake.recordInvocation("CreateTopicIfNotExists", []interface{}{topicId})
  fake.createTopicIfNotExistsMutex.Unlock()
  if fake.CreateTopicIfNotExistsStub != nil {
    return fake.CreateTopicIfNotExistsStub(topicId)
  } else {
    return fake.createTopicIfNotExistsReturns.result1, fake.createTopicIfNotExistsReturns.result2
  }
}

func (fake *PubSubProvider) CreateTopicIfNotExistsCallCount() int {
  fake.createTopicIfNotExistsMutex.RLock()
  defer fake.createTopicIfNotExistsMutex.RUnlock()
  return len(fake.createTopicIfNotExistsArgsForCall)
}

func (fake *PubSubProvider) CreateTopicIfNotExistsArgsForCall(i int) string {
  fake.createTopicIfNotExistsMutex.RLock()
  defer fake.createTopicIfNotExistsMutex.RUnlock()
  return fake.createTopicIfNotExistsArgsForCall[i].topicId
}

func (fake *PubSubProvider) CreateTopicIfNotExistsReturns(result1 pubsubprovider.Topic, result2 error) {
  fake.CreateTopicIfNotExistsStub = nil
  fake.createTopicIfNotExistsReturns = struct {
    result1 pubsubprovider.Topic
    result2 error
  }{result1, result2}
}

func (fake *PubSubProvider) DeleteTopicIfExists(topicId string) (err error) {
  fake.deleteTopicIfExistsMutex.Lock()
  fake.deleteTopicIfExistsArgsForCall = append(fake.deleteTopicIfExistsArgsForCall, struct {
    topicId string
  }{topicId})
  fake.recordInvocation("DeleteTopicIfExists", []interface{}{topicId})
  fake.deleteTopicIfExistsMutex.Unlock()
  if fake.DeleteTopicIfExistsStub != nil {
    return fake.DeleteTopicIfExistsStub(topicId)
  } else {
    return fake.deleteTopicIfExistsReturns.result1
  }
}

func (fake *PubSubProvider) DeleteTopicIfExistsCallCount() int {
  fake.deleteTopicIfExistsMutex.RLock()
  defer fake.deleteTopicIfExistsMutex.RUnlock()
  return len(fake.deleteTopicIfExistsArgsForCall)
}

func (fake *PubSubProvider) DeleteTopicIfExistsArgsForCall(i int) string {
  fake.deleteTopicIfExistsMutex.RLock()
  defer fake.deleteTopicIfExistsMutex.RUnlock()
  return fake.deleteTopicIfExistsArgsForCall[i].topicId
}

func (fake *PubSubProvider) DeleteTopicIfExistsReturns(result1 error) {
  fake.DeleteTopicIfExistsStub = nil
  fake.deleteTopicIfExistsReturns = struct {
    result1 error
  }{result1}
}

func (fake *PubSubProvider) GetTopic(topicId string) (topic pubsubprovider.Topic, err error) {
  fake.getTopicMutex.Lock()
  fake.getTopicArgsForCall = append(fake.getTopicArgsForCall, struct {
    topicId string
  }{topicId})
  fake.recordInvocation("GetTopic", []interface{}{topicId})
  fake.getTopicMutex.Unlock()
  if fake.GetTopicStub != nil {
    return fake.GetTopicStub(topicId)
  } else {
    return fake.getTopicReturns.result1, fake.getTopicReturns.result2
  }
}

func (fake *PubSubProvider) GetTopicCallCount() int {
  fake.getTopicMutex.RLock()
  defer fake.getTopicMutex.RUnlock()
  return len(fake.getTopicArgsForCall)
}

func (fake *PubSubProvider) GetTopicArgsForCall(i int) string {
  fake.getTopicMutex.RLock()
  defer fake.getTopicMutex.RUnlock()
  return fake.getTopicArgsForCall[i].topicId
}

func (fake *PubSubProvider) GetTopicReturns(result1 pubsubprovider.Topic, result2 error) {
  fake.GetTopicStub = nil
  fake.getTopicReturns = struct {
    result1 pubsubprovider.Topic
    result2 error
  }{result1, result2}
}

func (fake *PubSubProvider) Invocations() map[string][][]interface{} {
  fake.invocationsMutex.RLock()
  defer fake.invocationsMutex.RUnlock()
  fake.createTopicIfNotExistsMutex.RLock()
  defer fake.createTopicIfNotExistsMutex.RUnlock()
  fake.deleteTopicIfExistsMutex.RLock()
  defer fake.deleteTopicIfExistsMutex.RUnlock()
  fake.getTopicMutex.RLock()
  defer fake.getTopicMutex.RUnlock()
  return fake.invocations
}

func (fake *PubSubProvider) recordInvocation(key string, args []interface{}) {
  fake.invocationsMutex.Lock()
  defer fake.invocationsMutex.Unlock()
  if fake.invocations == nil {
    fake.invocations = map[string][][]interface{}{}
  }
  if fake.invocations[key] == nil {
    fake.invocations[key] = [][]interface{}{}
  }
  fake.invocations[key] = append(fake.invocations[key], args)
}

var _ pubsubprovider.PubSubProvider = new(PubSubProvider)
