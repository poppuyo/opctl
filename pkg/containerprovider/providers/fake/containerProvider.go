// This file was generated by counterfeiter
package fake

import (
  "io"
  "sync"

  "github.com/opspec-io/engine/pkg/containerprovider"
)

type ContainerProvider struct {
  BindContainerToNetworkStub            func(containerId string, networkBinding *containerprovider.NetEntry) (err error)
  bindContainerToNetworkMutex           sync.RWMutex
  bindContainerToNetworkArgsForCall     []struct {
    containerId    string
    networkBinding *containerprovider.NetEntry
  }
  bindContainerToNetworkReturns         struct {
                                          result1 error
                                        }
  CreateNetworkStub                     func() (networkId string, err error)
  createNetworkMutex                    sync.RWMutex
  createNetworkArgsForCall              []struct{}
  createNetworkReturns                  struct {
                                          result1 string
                                          result2 error
                                        }
  CloneVolumeStub                       func(srcVolumeId string) (dstVolumeId string, err error)
  cloneVolumeMutex                      sync.RWMutex
  cloneVolumeArgsForCall                []struct {
    srcVolumeId string
  }
  cloneVolumeReturns                    struct {
                                          result1 string
                                          result2 error
                                        }
  CreateVolumeFromTgzArchiveStub        func(tgzArchive io.Reader) (volumeId string, err error)
  createVolumeFromTgzArchiveMutex       sync.RWMutex
  createVolumeFromTgzArchiveArgsForCall []struct {
    tgzArchive io.Reader
  }
  createVolumeFromTgzArchiveReturns     struct {
                                          result1 string
                                          result2 error
                                        }
  DeleteContainerIfExistsStub           func(containerId string) (err error)
  deleteContainerIfExistsMutex          sync.RWMutex
  deleteContainerIfExistsArgsForCall    []struct {
    containerId string
  }
  deleteContainerIfExistsReturns        struct {
                                          result1 error
                                        }
  DeleteNetworkIfExistsStub             func(networkId string)
  deleteNetworkIfExistsMutex            sync.RWMutex
  deleteNetworkIfExistsArgsForCall      []struct {
    networkId string
  }
  DeleteVolumeIfExistsStub              func(volumeId string) (err error)
  deleteVolumeIfExistsMutex             sync.RWMutex
  deleteVolumeIfExistsArgsForCall       []struct {
    volumeId string
  }
  deleteVolumeIfExistsReturns           struct {
                                          result1 error
                                        }
  ExportVolumeToTgzArchiveStub          func(volumeId string) (tgzArchive io.ReadCloser, err error)
  exportVolumeToTgzArchiveMutex         sync.RWMutex
  exportVolumeToTgzArchiveArgsForCall   []struct {
    volumeId string
  }
  exportVolumeToTgzArchiveReturns       struct {
                                          result1 io.ReadCloser
                                          result2 error
                                        }
  StartContainerStub                    func(envBindings []*containerprovider.EnvEntry, image string, fsBindings []*containerprovider.FsEntry, netBindings []*containerprovider.NetEntry) (containerId string, err error)
  startContainerMutex                   sync.RWMutex
  startContainerArgsForCall             []struct {
    envBindings []*containerprovider.EnvEntry
    image       string
    fsBindings  []*containerprovider.FsEntry
    netBindings []*containerprovider.NetEntry
  }
  startContainerReturns                 struct {
                                          result1 string
                                          result2 error
                                        }
  invocations                           map[string][][]interface{}
  invocationsMutex                      sync.RWMutex
}

func (fake *ContainerProvider) BindContainerToNetwork(containerId string, networkBinding *containerprovider.NetEntry) (err error) {
  fake.bindContainerToNetworkMutex.Lock()
  fake.bindContainerToNetworkArgsForCall = append(fake.bindContainerToNetworkArgsForCall, struct {
    containerId    string
    networkBinding *containerprovider.NetEntry
  }{containerId, networkBinding})
  fake.recordInvocation("BindContainerToNetwork", []interface{}{containerId, networkBinding})
  fake.bindContainerToNetworkMutex.Unlock()
  if fake.BindContainerToNetworkStub != nil {
    return fake.BindContainerToNetworkStub(containerId, networkBinding)
  } else {
    return fake.bindContainerToNetworkReturns.result1
  }
}

func (fake *ContainerProvider) BindContainerToNetworkCallCount() int {
  fake.bindContainerToNetworkMutex.RLock()
  defer fake.bindContainerToNetworkMutex.RUnlock()
  return len(fake.bindContainerToNetworkArgsForCall)
}

func (fake *ContainerProvider) BindContainerToNetworkArgsForCall(i int) (string, *containerprovider.NetEntry) {
  fake.bindContainerToNetworkMutex.RLock()
  defer fake.bindContainerToNetworkMutex.RUnlock()
  return fake.bindContainerToNetworkArgsForCall[i].containerId, fake.bindContainerToNetworkArgsForCall[i].networkBinding
}

func (fake *ContainerProvider) BindContainerToNetworkReturns(result1 error) {
  fake.BindContainerToNetworkStub = nil
  fake.bindContainerToNetworkReturns = struct {
    result1 error
  }{result1}
}

func (fake *ContainerProvider) CreateNetwork() (networkId string, err error) {
  fake.createNetworkMutex.Lock()
  fake.createNetworkArgsForCall = append(fake.createNetworkArgsForCall, struct{}{})
  fake.recordInvocation("CreateNetwork", []interface{}{})
  fake.createNetworkMutex.Unlock()
  if fake.CreateNetworkStub != nil {
    return fake.CreateNetworkStub()
  } else {
    return fake.createNetworkReturns.result1, fake.createNetworkReturns.result2
  }
}

func (fake *ContainerProvider) CreateNetworkCallCount() int {
  fake.createNetworkMutex.RLock()
  defer fake.createNetworkMutex.RUnlock()
  return len(fake.createNetworkArgsForCall)
}

func (fake *ContainerProvider) CreateNetworkReturns(result1 string, result2 error) {
  fake.CreateNetworkStub = nil
  fake.createNetworkReturns = struct {
    result1 string
    result2 error
  }{result1, result2}
}

func (fake *ContainerProvider) CloneVolume(srcVolumeId string) (dstVolumeId string, err error) {
  fake.cloneVolumeMutex.Lock()
  fake.cloneVolumeArgsForCall = append(fake.cloneVolumeArgsForCall, struct {
    srcVolumeId string
  }{srcVolumeId})
  fake.recordInvocation("CloneVolume", []interface{}{srcVolumeId})
  fake.cloneVolumeMutex.Unlock()
  if fake.CloneVolumeStub != nil {
    return fake.CloneVolumeStub(srcVolumeId)
  } else {
    return fake.cloneVolumeReturns.result1, fake.cloneVolumeReturns.result2
  }
}

func (fake *ContainerProvider) CloneVolumeCallCount() int {
  fake.cloneVolumeMutex.RLock()
  defer fake.cloneVolumeMutex.RUnlock()
  return len(fake.cloneVolumeArgsForCall)
}

func (fake *ContainerProvider) CloneVolumeArgsForCall(i int) string {
  fake.cloneVolumeMutex.RLock()
  defer fake.cloneVolumeMutex.RUnlock()
  return fake.cloneVolumeArgsForCall[i].srcVolumeId
}

func (fake *ContainerProvider) CloneVolumeReturns(result1 string, result2 error) {
  fake.CloneVolumeStub = nil
  fake.cloneVolumeReturns = struct {
    result1 string
    result2 error
  }{result1, result2}
}

func (fake *ContainerProvider) CreateVolumeFromTgzArchive(tgzArchive io.Reader) (volumeId string, err error) {
  fake.createVolumeFromTgzArchiveMutex.Lock()
  fake.createVolumeFromTgzArchiveArgsForCall = append(fake.createVolumeFromTgzArchiveArgsForCall, struct {
    tgzArchive io.Reader
  }{tgzArchive})
  fake.recordInvocation("CreateVolumeFromTgzArchive", []interface{}{tgzArchive})
  fake.createVolumeFromTgzArchiveMutex.Unlock()
  if fake.CreateVolumeFromTgzArchiveStub != nil {
    return fake.CreateVolumeFromTgzArchiveStub(tgzArchive)
  } else {
    return fake.createVolumeFromTgzArchiveReturns.result1, fake.createVolumeFromTgzArchiveReturns.result2
  }
}

func (fake *ContainerProvider) CreateVolumeFromTgzArchiveCallCount() int {
  fake.createVolumeFromTgzArchiveMutex.RLock()
  defer fake.createVolumeFromTgzArchiveMutex.RUnlock()
  return len(fake.createVolumeFromTgzArchiveArgsForCall)
}

func (fake *ContainerProvider) CreateVolumeFromTgzArchiveArgsForCall(i int) io.Reader {
  fake.createVolumeFromTgzArchiveMutex.RLock()
  defer fake.createVolumeFromTgzArchiveMutex.RUnlock()
  return fake.createVolumeFromTgzArchiveArgsForCall[i].tgzArchive
}

func (fake *ContainerProvider) CreateVolumeFromTgzArchiveReturns(result1 string, result2 error) {
  fake.CreateVolumeFromTgzArchiveStub = nil
  fake.createVolumeFromTgzArchiveReturns = struct {
    result1 string
    result2 error
  }{result1, result2}
}

func (fake *ContainerProvider) DeleteContainerIfExists(containerId string) (err error) {
  fake.deleteContainerIfExistsMutex.Lock()
  fake.deleteContainerIfExistsArgsForCall = append(fake.deleteContainerIfExistsArgsForCall, struct {
    containerId string
  }{containerId})
  fake.recordInvocation("DeleteContainerIfExists", []interface{}{containerId})
  fake.deleteContainerIfExistsMutex.Unlock()
  if fake.DeleteContainerIfExistsStub != nil {
    return fake.DeleteContainerIfExistsStub(containerId)
  } else {
    return fake.deleteContainerIfExistsReturns.result1
  }
}

func (fake *ContainerProvider) DeleteContainerIfExistsCallCount() int {
  fake.deleteContainerIfExistsMutex.RLock()
  defer fake.deleteContainerIfExistsMutex.RUnlock()
  return len(fake.deleteContainerIfExistsArgsForCall)
}

func (fake *ContainerProvider) DeleteContainerIfExistsArgsForCall(i int) string {
  fake.deleteContainerIfExistsMutex.RLock()
  defer fake.deleteContainerIfExistsMutex.RUnlock()
  return fake.deleteContainerIfExistsArgsForCall[i].containerId
}

func (fake *ContainerProvider) DeleteContainerIfExistsReturns(result1 error) {
  fake.DeleteContainerIfExistsStub = nil
  fake.deleteContainerIfExistsReturns = struct {
    result1 error
  }{result1}
}

func (fake *ContainerProvider) DeleteNetworkIfExists(networkId string) {
  fake.deleteNetworkIfExistsMutex.Lock()
  fake.deleteNetworkIfExistsArgsForCall = append(fake.deleteNetworkIfExistsArgsForCall, struct {
    networkId string
  }{networkId})
  fake.recordInvocation("DeleteNetworkIfExists", []interface{}{networkId})
  fake.deleteNetworkIfExistsMutex.Unlock()
  if fake.DeleteNetworkIfExistsStub != nil {
    fake.DeleteNetworkIfExistsStub(networkId)
  }
}

func (fake *ContainerProvider) DeleteNetworkIfExistsCallCount() int {
  fake.deleteNetworkIfExistsMutex.RLock()
  defer fake.deleteNetworkIfExistsMutex.RUnlock()
  return len(fake.deleteNetworkIfExistsArgsForCall)
}

func (fake *ContainerProvider) DeleteNetworkIfExistsArgsForCall(i int) string {
  fake.deleteNetworkIfExistsMutex.RLock()
  defer fake.deleteNetworkIfExistsMutex.RUnlock()
  return fake.deleteNetworkIfExistsArgsForCall[i].networkId
}

func (fake *ContainerProvider) DeleteVolumeIfExists(volumeId string) (err error) {
  fake.deleteVolumeIfExistsMutex.Lock()
  fake.deleteVolumeIfExistsArgsForCall = append(fake.deleteVolumeIfExistsArgsForCall, struct {
    volumeId string
  }{volumeId})
  fake.recordInvocation("DeleteVolumeIfExists", []interface{}{volumeId})
  fake.deleteVolumeIfExistsMutex.Unlock()
  if fake.DeleteVolumeIfExistsStub != nil {
    return fake.DeleteVolumeIfExistsStub(volumeId)
  } else {
    return fake.deleteVolumeIfExistsReturns.result1
  }
}

func (fake *ContainerProvider) DeleteVolumeIfExistsCallCount() int {
  fake.deleteVolumeIfExistsMutex.RLock()
  defer fake.deleteVolumeIfExistsMutex.RUnlock()
  return len(fake.deleteVolumeIfExistsArgsForCall)
}

func (fake *ContainerProvider) DeleteVolumeIfExistsArgsForCall(i int) string {
  fake.deleteVolumeIfExistsMutex.RLock()
  defer fake.deleteVolumeIfExistsMutex.RUnlock()
  return fake.deleteVolumeIfExistsArgsForCall[i].volumeId
}

func (fake *ContainerProvider) DeleteVolumeIfExistsReturns(result1 error) {
  fake.DeleteVolumeIfExistsStub = nil
  fake.deleteVolumeIfExistsReturns = struct {
    result1 error
  }{result1}
}

func (fake *ContainerProvider) ExportVolumeToTgzArchive(volumeId string) (tgzArchive io.ReadCloser, err error) {
  fake.exportVolumeToTgzArchiveMutex.Lock()
  fake.exportVolumeToTgzArchiveArgsForCall = append(fake.exportVolumeToTgzArchiveArgsForCall, struct {
    volumeId string
  }{volumeId})
  fake.recordInvocation("ExportVolumeToTgzArchive", []interface{}{volumeId})
  fake.exportVolumeToTgzArchiveMutex.Unlock()
  if fake.ExportVolumeToTgzArchiveStub != nil {
    return fake.ExportVolumeToTgzArchiveStub(volumeId)
  } else {
    return fake.exportVolumeToTgzArchiveReturns.result1, fake.exportVolumeToTgzArchiveReturns.result2
  }
}

func (fake *ContainerProvider) ExportVolumeToTgzArchiveCallCount() int {
  fake.exportVolumeToTgzArchiveMutex.RLock()
  defer fake.exportVolumeToTgzArchiveMutex.RUnlock()
  return len(fake.exportVolumeToTgzArchiveArgsForCall)
}

func (fake *ContainerProvider) ExportVolumeToTgzArchiveArgsForCall(i int) string {
  fake.exportVolumeToTgzArchiveMutex.RLock()
  defer fake.exportVolumeToTgzArchiveMutex.RUnlock()
  return fake.exportVolumeToTgzArchiveArgsForCall[i].volumeId
}

func (fake *ContainerProvider) ExportVolumeToTgzArchiveReturns(result1 io.ReadCloser, result2 error) {
  fake.ExportVolumeToTgzArchiveStub = nil
  fake.exportVolumeToTgzArchiveReturns = struct {
    result1 io.ReadCloser
    result2 error
  }{result1, result2}
}

func (fake *ContainerProvider) StartContainer(envBindings []*containerprovider.EnvEntry, image string, fsBindings []*containerprovider.FsEntry, netBindings []*containerprovider.NetEntry) (containerId string, err error) {
  var envBindingsCopy []*containerprovider.EnvEntry
  if envBindings != nil {
    envBindingsCopy = make([]*containerprovider.EnvEntry, len(envBindings))
    copy(envBindingsCopy, envBindings)
  }
  var fsBindingsCopy []*containerprovider.FsEntry
  if fsBindings != nil {
    fsBindingsCopy = make([]*containerprovider.FsEntry, len(fsBindings))
    copy(fsBindingsCopy, fsBindings)
  }
  var netBindingsCopy []*containerprovider.NetEntry
  if netBindings != nil {
    netBindingsCopy = make([]*containerprovider.NetEntry, len(netBindings))
    copy(netBindingsCopy, netBindings)
  }
  fake.startContainerMutex.Lock()
  fake.startContainerArgsForCall = append(fake.startContainerArgsForCall, struct {
    envBindings []*containerprovider.EnvEntry
    image       string
    fsBindings  []*containerprovider.FsEntry
    netBindings []*containerprovider.NetEntry
  }{envBindingsCopy, image, fsBindingsCopy, netBindingsCopy})
  fake.recordInvocation("StartContainer", []interface{}{envBindingsCopy, image, fsBindingsCopy, netBindingsCopy})
  fake.startContainerMutex.Unlock()
  if fake.StartContainerStub != nil {
    return fake.StartContainerStub(envBindings, image, fsBindings, netBindings)
  } else {
    return fake.startContainerReturns.result1, fake.startContainerReturns.result2
  }
}

func (fake *ContainerProvider) StartContainerCallCount() int {
  fake.startContainerMutex.RLock()
  defer fake.startContainerMutex.RUnlock()
  return len(fake.startContainerArgsForCall)
}

func (fake *ContainerProvider) StartContainerArgsForCall(i int) ([]*containerprovider.EnvEntry, string, []*containerprovider.FsEntry, []*containerprovider.NetEntry) {
  fake.startContainerMutex.RLock()
  defer fake.startContainerMutex.RUnlock()
  return fake.startContainerArgsForCall[i].envBindings, fake.startContainerArgsForCall[i].image, fake.startContainerArgsForCall[i].fsBindings, fake.startContainerArgsForCall[i].netBindings
}

func (fake *ContainerProvider) StartContainerReturns(result1 string, result2 error) {
  fake.StartContainerStub = nil
  fake.startContainerReturns = struct {
    result1 string
    result2 error
  }{result1, result2}
}

func (fake *ContainerProvider) Invocations() map[string][][]interface{} {
  fake.invocationsMutex.RLock()
  defer fake.invocationsMutex.RUnlock()
  fake.bindContainerToNetworkMutex.RLock()
  defer fake.bindContainerToNetworkMutex.RUnlock()
  fake.createNetworkMutex.RLock()
  defer fake.createNetworkMutex.RUnlock()
  fake.cloneVolumeMutex.RLock()
  defer fake.cloneVolumeMutex.RUnlock()
  fake.createVolumeFromTgzArchiveMutex.RLock()
  defer fake.createVolumeFromTgzArchiveMutex.RUnlock()
  fake.deleteContainerIfExistsMutex.RLock()
  defer fake.deleteContainerIfExistsMutex.RUnlock()
  fake.deleteNetworkIfExistsMutex.RLock()
  defer fake.deleteNetworkIfExistsMutex.RUnlock()
  fake.deleteVolumeIfExistsMutex.RLock()
  defer fake.deleteVolumeIfExistsMutex.RUnlock()
  fake.exportVolumeToTgzArchiveMutex.RLock()
  defer fake.exportVolumeToTgzArchiveMutex.RUnlock()
  fake.startContainerMutex.RLock()
  defer fake.startContainerMutex.RUnlock()
  return fake.invocations
}

func (fake *ContainerProvider) recordInvocation(key string, args []interface{}) {
  fake.invocationsMutex.Lock()
  defer fake.invocationsMutex.Unlock()
  if fake.invocations == nil {
    fake.invocations = map[string][][]interface{}{}
  }
  if fake.invocations[key] == nil {
    fake.invocations[key] = [][]interface{}{}
  }
  fake.invocations[key] = append(fake.invocations[key], args)
}

var _ containerprovider.ContainerProvider = new(ContainerProvider)
